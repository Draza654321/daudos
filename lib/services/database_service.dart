import 'dart:async';
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import '../models/user.dart';
import '../models/mood.dart';
import '../models/task.dart';
import '../models/habit.dart';
import '../models/goal.dart';
import '../models/mind_gym.dart';
import '../models/settings.dart';
import '../models/analytics.dart';

class DatabaseService {
  static final DatabaseService _instance = DatabaseService._internal();
  factory DatabaseService() => _instance;
  DatabaseService._internal();

  static Database? _database;

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase();
    return _database!;
  }

  Future<Database> _initDatabase() async {
    String path = join(await getDatabasesPath(), 'daudos.db');
    return await openDatabase(
      path,
      version: 1,
      onCreate: _createTables,
      onUpgrade: _upgradeDatabase,
    );
  }

  Future<void> _createTables(Database db, int version) async {
    // Users table
    await db.execute('''
      CREATE TABLE users (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        workStartTime TEXT NOT NULL,
        workEndTime TEXT NOT NULL,
        timezone TEXT NOT NULL,
        monthlyIncomeGoal REAL NOT NULL,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL
      )
    ''');

    // Moods table
    await db.execute('''
      CREATE TABLE moods (
        id TEXT PRIMARY KEY,
        userId TEXT NOT NULL,
        clarity INTEGER NOT NULL,
        focus INTEGER NOT NULL,
        energy INTEGER NOT NULL,
        notes TEXT,
        timestamp TEXT NOT NULL,
        FOREIGN KEY (userId) REFERENCES users (id)
      )
    ''');

    // Tasks table
    await db.execute('''
      CREATE TABLE tasks (
        id TEXT PRIMARY KEY,
        userId TEXT NOT NULL,
        title TEXT NOT NULL,
        description TEXT,
        priority TEXT NOT NULL,
        category TEXT NOT NULL,
        status TEXT NOT NULL,
        isAutoGenerated INTEGER NOT NULL,
        dueDate TEXT,
        completedAt TEXT,
        estimatedMinutes INTEGER,
        actualMinutes INTEGER,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL,
        FOREIGN KEY (userId) REFERENCES users (id)
      )
    ''');

    // Habits table
    await db.execute('''
      CREATE TABLE habits (
        id TEXT PRIMARY KEY,
        userId TEXT NOT NULL,
        name TEXT NOT NULL,
        description TEXT,
        type TEXT NOT NULL,
        frequency TEXT NOT NULL,
        targetCount INTEGER NOT NULL,
        isActive INTEGER NOT NULL,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL,
        FOREIGN KEY (userId) REFERENCES users (id)
      )
    ''');

    // Habit entries table
    await db.execute('''
      CREATE TABLE habit_entries (
        id TEXT PRIMARY KEY,
        habitId TEXT NOT NULL,
        userId TEXT NOT NULL,
        date TEXT NOT NULL,
        completed INTEGER NOT NULL,
        notes TEXT,
        createdAt TEXT NOT NULL,
        FOREIGN KEY (habitId) REFERENCES habits (id),
        FOREIGN KEY (userId) REFERENCES users (id)
      )
    ''');

    // Goals table
    await db.execute('''
      CREATE TABLE goals (
        id TEXT PRIMARY KEY,
        userId TEXT NOT NULL,
        title TEXT NOT NULL,
        description TEXT NOT NULL,
        category TEXT NOT NULL,
        status TEXT NOT NULL,
        targetDate TEXT NOT NULL,
        progress REAL NOT NULL,
        milestones TEXT NOT NULL,
        milestoneCompleted TEXT NOT NULL,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL,
        FOREIGN KEY (userId) REFERENCES users (id)
      )
    ''');

    // Mind gym sessions table
    await db.execute('''
      CREATE TABLE mind_gym_sessions (
        id TEXT PRIMARY KEY,
        userId TEXT NOT NULL,
        startTime TEXT NOT NULL,
        endTime TEXT,
        completedActivities TEXT NOT NULL,
        activityDurations TEXT NOT NULL,
        notes TEXT,
        overallRating INTEGER,
        createdAt TEXT NOT NULL,
        FOREIGN KEY (userId) REFERENCES users (id)
      )
    ''');

    // Brain dump entries table
    await db.execute('''
      CREATE TABLE brain_dump_entries (
        id TEXT PRIMARY KEY,
        userId TEXT NOT NULL,
        content TEXT NOT NULL,
        emotionTags TEXT NOT NULL,
        timestamp TEXT NOT NULL,
        FOREIGN KEY (userId) REFERENCES users (id)
      )
    ''');

    // Settings table
    await db.execute('''
      CREATE TABLE settings (
        id TEXT PRIMARY KEY,
        userId TEXT NOT NULL,
        uiMode TEXT NOT NULL,
        ttsEnabled INTEGER NOT NULL,
        ttsSpeed REAL NOT NULL,
        notificationsEnabled INTEGER NOT NULL,
        motivationEngineEnabled INTEGER NOT NULL,
        appLockEnabled INTEGER NOT NULL,
        appLockPin TEXT,
        biometricLockEnabled INTEGER NOT NULL,
        firebaseBackupEnabled INTEGER NOT NULL,
        backupFrequency TEXT NOT NULL,
        offlineFirstEnabled INTEGER NOT NULL,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL,
        FOREIGN KEY (userId) REFERENCES users (id)
      )
    ''');

    // Daily analytics table
    await db.execute('''
      CREATE TABLE daily_analytics (
        id TEXT PRIMARY KEY,
        userId TEXT NOT NULL,
        date TEXT NOT NULL,
        tasksCompleted INTEGER NOT NULL,
        tasksTotal INTEGER NOT NULL,
        habitsCompleted INTEGER NOT NULL,
        habitsTotal INTEGER NOT NULL,
        mindGymMinutes INTEGER NOT NULL,
        averageMoodScore REAL NOT NULL,
        incomeProgress REAL NOT NULL,
        streakDays INTEGER NOT NULL,
        createdAt TEXT NOT NULL,
        FOREIGN KEY (userId) REFERENCES users (id)
      )
    ''');

    // Sync queue table for offline operations
    await db.execute('''
      CREATE TABLE sync_queue (
        id TEXT PRIMARY KEY,
        operation TEXT NOT NULL,
        tableName TEXT NOT NULL,
        recordId TEXT NOT NULL,
        data TEXT NOT NULL,
        timestamp TEXT NOT NULL,
        synced INTEGER NOT NULL DEFAULT 0
      )
    ''');
  }

  Future<void> _upgradeDatabase(Database db, int oldVersion, int newVersion) async {
    // Handle database upgrades here
  }

  // Generic CRUD operations
  Future<int> insert(String table, Map<String, dynamic> data) async {
    final db = await database;
    return await db.insert(table, data, conflictAlgorithm: ConflictAlgorithm.replace);
  }

  Future<List<Map<String, dynamic>>> query(String table, {
    String? where,
    List<dynamic>? whereArgs,
    String? orderBy,
    int? limit,
  }) async {
    final db = await database;
    return await db.query(
      table,
      where: where,
      whereArgs: whereArgs,
      orderBy: orderBy,
      limit: limit,
    );
  }

  Future<int> update(String table, Map<String, dynamic> data, String where, List<dynamic> whereArgs) async {
    final db = await database;
    return await db.update(table, data, where: where, whereArgs: whereArgs);
  }

  Future<int> delete(String table, String where, List<dynamic> whereArgs) async {
    final db = await database;
    return await db.delete(table, where: where, whereArgs: whereArgs);
  }

  // Add operation to sync queue
  Future<void> addToSyncQueue(String operation, String tableName, String recordId, Map<String, dynamic> data) async {
    await insert('sync_queue', {
      'id': 'sync_${DateTime.now().millisecondsSinceEpoch}',
      'operation': operation,
      'tableName': tableName,
      'recordId': recordId,
      'data': data.toString(),
      'timestamp': DateTime.now().toIso8601String(),
      'synced': 0,
    });
  }

  // Get pending sync operations
  Future<List<Map<String, dynamic>>> getPendingSyncOperations() async {
    return await query('sync_queue', where: 'synced = ?', whereArgs: [0]);
  }

  // Mark sync operation as completed
  Future<void> markSyncCompleted(String syncId) async {
    await update('sync_queue', {'synced': 1}, 'id = ?', [syncId]);
  }

  // Clear old sync records
  Future<void> clearOldSyncRecords() async {
    final oneWeekAgo = DateTime.now().subtract(Duration(days: 7)).toIso8601String();
    await delete('sync_queue', 'timestamp < ? AND synced = 1', [oneWeekAgo]);
  }

  // Close database
  Future<void> close() async {
    final db = await database;
    await db.close();
  }
}

